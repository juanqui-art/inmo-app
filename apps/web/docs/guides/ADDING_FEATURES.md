# Gu√≠a: Agregando una Nueva Feature

Paso a paso para implementar una feature completa en InmoApp.

---

## üìã Overview

Implementar una feature en InmoApp involucra estos pasos:

```
1. Planificar      ‚Üê Entender qu√© vas a hacer
2. Dise√±ar         ‚Üê C√≥mo encaja en la arquitectura
3. Backend         ‚Üê Database, Server Actions, Validations
4. Frontend        ‚Üê Components, Hooks, UI
5. Testing         ‚Üê Manual testing
6. Documentaci√≥n   ‚Üê Actualizar docs
7. Commit          ‚Üê Git commit con descripci√≥n
```

**Tiempo estimado:** 2-4 horas para feature peque√±a

---

## 1Ô∏è‚É£ Planificaci√≥n

### Responde estas preguntas:

**¬øQu√© es la feature?**
```
Ejemplo: "Agregar b√∫squeda de propiedades por texto"
```

**¬øQui√©n la necesita?**
```
Ejemplo: "Usuarios que quieren encontrar propiedades sin scroll"
```

**¬øC√≥mo funciona?**
```
Ejemplo: "Input de b√∫squeda ‚Üí filtra properties por t√≠tulo"
```

**¬øAfecta a qu√© componentes?**
```
Ejemplo: "MapView, MapContainer, MapFilters (a crear)"
```

**¬øHay dependencias?**
```
Ejemplo: "Requiere backend filtering (ya existe)"
```

### Crear un ticket

Documenta en un comment o issue:
```markdown
## B√∫squeda de Propiedades

### Descripci√≥n
Agregar campo de b√∫squeda que filtre properties por texto.

### Criterios de Aceptaci√≥n
- [ ] Campo de b√∫squeda visible en navbar
- [ ] Filtra properties mientras escribes
- [ ] Debounce de 300ms para no spamear requests
- [ ] Clear button para limpiar b√∫squeda

### Mockups
[Adjuntar screenshot]

### Tareas
- [ ] Backend: Agregar text search a repositorio
- [ ] Frontend: Crear SearchInput component
- [ ] Integraci√≥n: Conectar input con backend
- [ ] Testing: Verificar que funciona
```

---

## 2Ô∏è‚É£ Dise√±o Arquitect√≥nico

### Entender la arquitectura actual

Revisa [Architecture.md](../ARCHITECTURE.md):
- ¬øEs Server Component o Client Component?
- ¬øNecesito Server Action?
- ¬øNecesito cambios en la base de datos?

### Data Flow para Search

```
SearchInput (Client)
  ‚Üì onChange
[Debounce 300ms]
  ‚Üì
router.push('/mapa?search=...')
  ‚Üì
MapPage (Server Component)
  ‚Üì
searchParams.search
  ‚Üì
getCachedPropertiesBySearch(search)
  ‚Üì
Prisma.property.findMany({ where: { title: { contains: search } } })
  ‚Üì
MapView re-renderiza con nuevas properties
```

### Dibujar el componente tree

```
MapPage (Server)
  ‚îú‚îÄ‚îÄ Fetch properties filtered by search
  ‚îî‚îÄ‚îÄ <MapView> (Client)
       ‚îú‚îÄ‚îÄ <SearchInput />  ‚Üê NUEVO
       ‚îî‚îÄ‚îÄ <MapContainer>
```

---

## 3Ô∏è‚É£ Backend

### 3.1 Database (si es necesario)

**Pregunta:** ¬øNecesito nuevos campos o tablas?

Para b√∫squeda de propiedades por texto:
```prisma
// ‚ùå NO necesario: Property ya tiene 'title' y 'description'
model Property {
  id          String
  title       String  ‚Üê YA EXISTE
  description String  ‚Üê YA EXISTE
}
```

Si necesitas:
```prisma
// Editar: packages/database/prisma/schema.prisma
model Property {
  id       String
  title    String
  +fullText String? // Para b√∫squeda full-text (opcional)
}
```

Luego:
```bash
bunx prisma migration dev --name "add-full-text-search"
```

### 3.2 Repository (Server Query)

**Ubicaci√≥n:** `packages/database/repositories/`

```typescript
// repositories/property.ts
import { db } from '@/prisma'

export async function getPropertiesBySearch({
  search,
  minLatitude,
  maxLatitude,
  minLongitude,
  maxLongitude,
}) {
  return await db.property.findMany({
    where: {
      AND: [
        // B√∫squeda por texto
        {
          OR: [
            { title: { contains: search, mode: 'insensitive' } },
            { description: { contains: search, mode: 'insensitive' } },
          ],
        },
        // Bounds (spatial filter)
        {
          latitude: { gte: minLatitude, lte: maxLatitude },
          longitude: { gte: minLongitude, lte: maxLongitude },
        },
      ],
    },
    take: 1000, // Limit
  });
}

// Usar React.cache() para deduplicaci√≥n
export const getCachedPropertiesBySearch = React.cache(getPropertiesBySearch);
```

### 3.3 Validaciones (Zod)

**Ubicaci√≥n:** `app/lib/validations/`

```typescript
// search.ts
import { z } from 'zod'

export const searchParamsSchema = z.object({
  search: z.string().max(100).optional(),
  ne_lat: z.coerce.number().optional(),
  ne_lng: z.coerce.number().optional(),
  sw_lat: z.coerce.number().optional(),
  sw_lng: z.coerce.number().optional(),
});

export type SearchParams = z.infer<typeof searchParamsSchema>;
```

---

## 4Ô∏è‚É£ Frontend

### 4.1 Crear Component

**Ubicaci√≥n:** `components/map/`

```typescript
// search-input.tsx
'use client'

import { useState, useCallback } from 'react'
import { useRouter } from 'next/navigation'
import { useDebounce } from '@/lib/hooks/use-debounce'

interface SearchInputProps {
  initialValue?: string
}

export function SearchInput({ initialValue = '' }: SearchInputProps) {
  const router = useRouter()
  const [value, setValue] = useState(initialValue)

  // Debounce b√∫squeda
  const debouncedSearch = useDebounce(value, 300)

  useEffect(() => {
    // Obtener bounds actuales de URL
    const params = new URLSearchParams(window.location.search)

    // Actualizar b√∫squeda
    if (debouncedSearch) {
      params.set('search', debouncedSearch)
    } else {
      params.delete('search')
    }

    router.push(`/mapa?${params.toString()}`)
  }, [debouncedSearch, router])

  return (
    <div className="flex gap-2">
      <input
        type="text"
        value={value}
        onChange={(e) => setValue(e.target.value)}
        placeholder="Buscar propiedades..."
        className="flex-1 px-3 py-2 rounded border border-border bg-background"
      />
      {value && (
        <button
          onClick={() => setValue('')}
          className="px-3 py-2 text-sm font-medium"
        >
          Limpiar
        </button>
      )}
    </div>
  )
}
```

### 4.2 Integrar en MapPage

**Ubicaci√≥n:** `app/(public)/mapa/page.tsx`

```typescript
export default async function MapPage(props: MapPageProps) {
  const searchParams = await props.searchParams

  // ‚úÖ Parsear b√∫squeda
  const search = searchParams.search as string | undefined
  const bounds = parseBoundsParams(searchParams, defaultViewport)

  // ‚úÖ Fetch con b√∫squeda
  const properties = await getCachedPropertiesBySearch({
    search,
    minLatitude: bounds.sw_lat,
    maxLatitude: bounds.ne_lat,
    minLongitude: bounds.sw_lng,
    maxLongitude: bounds.ne_lng,
  })

  const viewport = boundsToViewport(bounds)

  return (
    <MapView
      properties={properties}
      initialViewport={viewport}
      initialSearch={search}  // ‚Üê PASAR aqu√≠
    />
  )
}
```

### 4.3 Integrar en MapView

**Ubicaci√≥n:** `components/map/map-view.tsx`

```typescript
'use client'

interface MapViewProps {
  properties: MapProperty[]
  initialViewport: Viewport
  initialSearch?: string  // ‚Üê NUEVO
}

export function MapView({
  properties,
  initialViewport,
  initialSearch,
}: MapViewProps) {
  return (
    <>
      <SearchInput initialValue={initialSearch} />  {/* ‚Üê NUEVO */}
      <MapContainer {...} />
    </>
  )
}
```

---

## 5Ô∏è‚É£ Testing Manual

### Checklist

- [ ] Component renderiza sin errores
- [ ] Typing en SearchInput actualiza valor
- [ ] 300ms debounce funciona (espera antes de buscar)
- [ ] URL cambia cuando escribes
- [ ] Properties se filtran correctamente
- [ ] Clear button funciona
- [ ] Funciona con bounds tambi√©n (b√∫squeda + location)
- [ ] Dark mode se ve bien
- [ ] Mobile responsive
- [ ] Performance es bueno

### Testing Steps

```
1. Abre DevTools ‚Üí Console (para ver errores)
2. Abre /mapa
3. Escribe "casa" en SearchInput
4. Espera 300ms
5. Verifica que:
   - URL cambi√≥ a /mapa?search=casa
   - Properties se filtraron
   - No hay errores en console
6. Escribe m√°s: "casa grande"
7. Verifica que se re-filtra
8. Click "Limpiar"
9. Verifica que search se borra
```

---

## 6Ô∏è‚É£ Documentaci√≥n

### Actualizar docs

1. **Actualizar [MAP.md](../features/MAP.md)**
```markdown
### 6. Property Search
‚úÖ **Status:** Completado

B√∫squeda de properties por texto:
- Debounce 300ms
- Filtra por title y description
- Combina con location filtering
```

2. **Crear decision record si es necesario**
```
docs/decisions/SEARCH_IMPLEMENTATION.md
- Por qu√© usamos debounce
- Por qu√© server-side filtering
```

3. **Actualizar README.md**
```
docs/README.md
- Agregar link en Features ‚Üí Search
```

---

## 7Ô∏è‚É£ Git Commit

### Estructura de commit

```bash
git add .
git commit -m "feat(map): add property search with text filtering

- Add SearchInput component with 300ms debounce
- Implement server-side text search in getCachedPropertiesBySearch
- Add search params validation with Zod
- Integrate search with map bounds filtering
- Mobile responsive implementation

Fixes: #123 (si hay ticket relacionado)"
```

### Conventional Commits

```
feat(scope):    Nueva feature
fix(scope):     Fix de bug
refactor(scope): Cambios de c√≥digo sin funcionalidad nueva
docs(scope):    Solo cambios de documentaci√≥n
test(scope):    Solo tests
chore(scope):   Dependencies, build setup
```

---

## üìã Template R√°pido

Para no olvidar nada:

```markdown
## Feature: [Nombre]

### Planning
- [ ] Definir qu√©, c√≥mo, qui√©n
- [ ] Dibujar data flow
- [ ] Identificar cambios necesarios

### Backend
- [ ] Cambios a schema.prisma (si necesario)
- [ ] Crear/modificar repository
- [ ] Agregar validaciones Zod

### Frontend
- [ ] Crear componentes necesarios
- [ ] Conectar con server
- [ ] Integrar en page.tsx

### Testing
- [ ] Testing manual completado
- [ ] Error checking (console limpia)
- [ ] Dark mode tested
- [ ] Mobile responsive

### Documentation
- [ ] Actualizar feature docs
- [ ] Agregar decision record si necesario
- [ ] Actualizar README

### Commit
- [ ] Staging de archivos
- [ ] Mensaje de commit descriptivo
- [ ] type-check pasado
```

---

## üö® Errores Comunes

### Error 1: "Component 'X' is not exported"
```
Causa: Olvidaste hacer export en el archivo
Soluci√≥n: Agrega export antes del component
```

### Error 2: Server Action no funciona
```
Causa: Olvidaste 'use server' al inicio
Soluci√≥n: Agrega 'use server' en la action
```

### Error 3: searchParams no actualiza
```
Causa: No usaste router.push/replace con nuevos params
Soluci√≥n: Aseg√∫rate que router.push() se ejecuta
```

### Error 4: Infinite loop en useEffect
```
Causa: router o variables en dependencias
Soluci√≥n: Usa ref para trackear last state
```

### Error 5: Type errors despu√©s de cambios
```
Causa: TS no pas√≥ type-check
Soluci√≥n: bun run type-check y arregla errores
```

---

## üìö Recursos

- **[Architecture](../ARCHITECTURE.md)** - Entender c√≥mo funciona todo
- **[Database](../technical/DATABASE.md)** - C√≥mo agregar modelos
- **[Validations](../technical/HOOKS.md)** - Patterns de validaci√≥n
- **[Common Tasks](./COMMON_TASKS.md)** - Tasks repetitivas

---

## üéì Ejemplo Completo: Agregar Filtro de Precio

### 1. Planning
```
Feature: Price range filter
User: Quiero ver solo propiedades entre $100k-$500k
Data flow: URL params (minPrice, maxPrice) ‚Üí Server filter
```

### 2. Backend
```typescript
// repositories/property.ts
export async function getPropertiesByPriceRange({
  minPrice,
  maxPrice,
  ...bounds
}) {
  return await db.property.findMany({
    where: {
      AND: [
        { price: { gte: minPrice, lte: maxPrice } },
        // bounds...
      ],
    },
  });
}

// Exportar cached version
export const getCachedPropertiesByPriceRange = React.cache(getPropertiesByPriceRange);
```

### 3. Frontend
```typescript
// components/map/price-filter.tsx
'use client'

export function PriceFilter({ initialMin = 0, initialMax = 1000000 }) {
  const [min, setMin] = useState(initialMin);
  const [max, setMax] = useState(initialMax);
  const debouncedMin = useDebounce(min, 300);
  const debouncedMax = useDebounce(max, 300);

  useEffect(() => {
    // Update URL with price params
    const params = new URLSearchParams(window.location.search);
    params.set('minPrice', debouncedMin.toString());
    params.set('maxPrice', debouncedMax.toString());
    router.push(`/mapa?${params.toString()}`);
  }, [debouncedMin, debouncedMax, router]);

  return (
    <div className="flex gap-4">
      <input
        type="number"
        value={min}
        onChange={(e) => setMin(Number(e.target.value))}
        placeholder="Min price"
      />
      <input
        type="number"
        value={max}
        onChange={(e) => setMax(Number(e.target.value))}
        placeholder="Max price"
      />
    </div>
  );
}
```

### 4. Integration
```typescript
// app/(public)/mapa/page.tsx
const { minPrice, maxPrice } = searchParams;
const properties = await getCachedPropertiesByPriceRange({
  minPrice: Number(minPrice) || 0,
  maxPrice: Number(maxPrice) || 1000000,
  ...bounds,
});
```

### 5. Testing
```
‚úÖ Mover slider min ‚Üí properties se filtran
‚úÖ Mover slider max ‚Üí properties se filtran
‚úÖ Combo min+max ‚Üí funciona
‚úÖ URL tiene minPrice, maxPrice params
‚úÖ Refresh ‚Üí mantiene valores de URL
```

---

## üéØ Resumen

Agregar feature en InmoApp es un proceso sistem√°tico:

1. **Plan** bien antes de c√≥digo
2. **Backend** primero (data es King)
3. **Frontend** despu√©s (consume el backend)
4. **Test** manualmente todo
5. **Document** para el futuro
6. **Commit** con descripci√≥n clara

**Pro tip:** Usa este template para TODA feature, no importa el tama√±o.

---

**√öltima actualizaci√≥n:** 2025-10-24
**Mantenedor:** InmoApp Engineering Team
